@page "/data"
@using MudBlazor
@using MudBlazor.Charts
@using BlazorInterview.Models
@using BlazorInterview.Services
@inject DataService DataService

<div>
    <p>Line Chart showcasing Industrial PC (IPC)</p>
    <p>An IPC is considered underutilized if its average utilization rate is below 50% and its peak utilization rate is below 75%.</p>
    <p>Peak utilization is shown in blue and average utilization is shown in green.</p>
    <div style="margin: 10px;">
        <p>Choose a CpuMHz value that you would like to see the chart of</p>
        <InputSelect id="CPU" @bind-Value="selectedCpuMHz" @onchange="OnCpuSelectionChange">
            @foreach (var cpu in CpuMHzValues)
            {
                <option value="@cpu">@cpu</option>
            }
        </InputSelect>
    </div>
</div>
@if (chartDataByCpuMHz.ContainsKey(selectedCpuMHz))
{
    var cpuMHzData = chartDataByCpuMHz[selectedCpuMHz];
    <div>
        <div>
            <p>Grouped Data based on Maximum CPU MHz: @selectedCpuMHz (average of values is taken for each day)</p>
            <p>Average Utilization Rate: @cpuMHzData.AverageUtilizationRate%</p>
            <p>Peak Utilization Rate: @cpuMHzData.PeakUtilizationRate%</p>
            @if (cpuMHzData.IsUnderutilized)
            {
                <p style="color: green;">This IPC is underutilized.</p>
            }
            else
            {
                <p style="color: red;">This IPC is not underutilized.</p>
            }
        </div>
        <MudChart 
            ChartType="MudBlazor.ChartType.Line" 
            ChartSeries="@cpuMHzData.Series" 
            @bind-SelectedIndex="Index" 
            XAxisLabels="@cpuMHzData.XAxisLabels" 
            Width="100%" Height="350" 
            ChartOptions="@Options"/>
    </div>
}
@* @foreach (var cpuMHzData in chartDataByCpuMHz)
{
    <div>
        <div>
            <p>Grouped Data based on Maximum CPU MHz: @cpuMHzData.Key (average of values is taken for each day)</p>
            <p>Average Utilization Rate: @cpuMHzData.Value.AverageUtilizationRate%</p>
            <p>Peak Utilization Rate: @cpuMHzData.Value.PeakUtilizationRate%</p>
            @if (cpuMHzData.Value.IsUnderutilized)
            {
                <p style="color: green;">This IPC is underutilized.</p>
            }
            else
            {
                <p style="color: red;">This IPC is not underutilized.</p>
            }
        </div>
        <MudChart 
            ChartType="MudBlazor.ChartType.Line" 
            ChartSeries="@cpuMHzData.Value.Series" 
            @bind-SelectedIndex="Index" 
            XAxisLabels="@cpuMHzData.Value.XAxisLabels" 
            Width="100%" Height="350" 
            ChartOptions="@Options"/>
    </div>
} *@

@code 
{
    // variables for line chart
    private List<ChartSeries> Series = new List<ChartSeries>();
    private string[] XAxisLabels = Array.Empty<string>();
    private int Index = -1;
    private ChartOptions Options = new ChartOptions();
    private Dictionary<int, ChartData> chartDataByCpuMHz = new Dictionary<int, ChartData>();

    // variables for data
    private string csvFilePath = "sample-data/testcase_smart_applicator_V8.2_020823.zip.csv";
    private List<IPCData> IPCData = new List<IPCData>();
    private List<IPCData> selectedData = new List<IPCData>();

    // variables for input select
    public int selectedCpuMHz { get; set; }
    private List<int> CpuMHzValues = new List<int>();

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    private async Task LoadData()
    {
        IPCData = await DataService.LoadDataAsync(csvFilePath);
        // group data by value of CPU MHz, then by date, and take averages of avg and max Values for each day
       var groupedData = IPCData
            .GroupBy(d => d.CpuMHz)
            .SelectMany(cpuGroup => 
                cpuGroup.GroupBy(g => g.Time.Date)
                    .Select(dateGroup => new IPCData
                    {
                        Time = dateGroup.Key,
                        AvgValue = dateGroup.Average(d => d.AvgValue),
                        MaxValue = dateGroup.Average(d => d.MaxValue),
                        CpuMHz = cpuGroup.Key
                    })
            )
            .ToList();

        var selectedCpuMHzValues = groupedData.Select(d => d.CpuMHz).Distinct().ToList();
        Console.WriteLine($"Total number of distinct CpuMHz values: {selectedCpuMHzValues.Count()}");

        foreach (var cpuMHz in selectedCpuMHzValues)
        {
            CpuMHzValues.Add(cpuMHz);
            var dataCpuMhz = groupedData.Where(d => d.CpuMHz == cpuMHz).ToList();
            var maxValues = dataCpuMhz.Select(d => d.MaxValue).ToArray();
            var avgValues = dataCpuMhz.Select(d => d.AvgValue).ToArray();
            var averageUtilizationRate = Math.Round(avgValues.Average() / cpuMHz * 100, 2);
            var peakUtilizationRate = Math.Round(maxValues.Max() / cpuMHz * 100, 2);
            var isUnderutilized = averageUtilizationRate < 5 && peakUtilizationRate < 15;

            var ChartSeries = new List<ChartSeries>
                {
                    new ChartSeries { Name = "Peak Utilization", Data = maxValues },
                    new ChartSeries { Name = "Average Utilization", Data = avgValues }
                };

            var XAxisLabels = dataCpuMhz
                .Select((d, index) => index % 2 == 0 ? d.Time.ToString("dd") : "")
                .ToArray();

            chartDataByCpuMHz
                .Add(cpuMHz, new ChartData 
                    { 
                        Series = ChartSeries, 
                        XAxisLabels = XAxisLabels,
                        AverageUtilizationRate = averageUtilizationRate,
                        PeakUtilizationRate = peakUtilizationRate,
                        IsUnderutilized = isUnderutilized    
                    }
                );
        }
        selectedCpuMHz = CpuMHzValues.FirstOrDefault(); // set initial selected value
    }
    @* private void LoadChart(List<IPCData> data)
    {
        // clear the series and add new data
        Series.Clear();
        Series.Add(new ChartSeries { Name = "Peak Utilization", Data = maxValues });
        Series.Add(new ChartSeries { Name = "Average Utilization", Data = avgValues });
        // create x-axis labels, show every second entry
        XAxisLabels = data
            .Select((d, index) => index % 2 == 0 ? d.Time.ToString("dd") : "")
            .ToArray();
    } *@
    private class ChartData
    {
        public List<ChartSeries> Series { get; set; }
        public string[] XAxisLabels { get; set; }
        public double AverageUtilizationRate { get; set; }
        public double PeakUtilizationRate { get; set; }
        public bool IsUnderutilized { get; set; }
    }
    private void OnCpuSelectionChange(ChangeEventArgs e)
    {
        selectedCpuMHz = int.Parse(e.Value.ToString());
        StateHasChanged();
    }
}