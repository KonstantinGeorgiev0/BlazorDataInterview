@page "/factory-line"
@using MudBlazor
@using MudBlazor.Charts
@using BlazorInterview.Models
@using BlazorInterview.Services
@inject DataService DataService

<h3>Line Chart of IPCs grouped by their Data Factory.</h3>

@if (isLoading)
{
    <h3>Loading...</h3>
}
else
{
    @if (chartDataByFactory.ContainsKey(selectedFactory))
    {
        var factoryData = chartDataByFactory[selectedFactory];
        <div>
            <MudPaper Class="pa-3 mt-2 mb-2">
                <p>Choose a Data Factory number that you would like to see the chart of</p>
                <InputSelect class="form-control" style="width: 150px;" id="DataFactory" @bind-Value="selectedFactory" @onchange="OnFactorySelectionChange">
                    @foreach (var factory in FactoryValues)
                    {
                        <option value="@factory">@factory</option>
                    }
                </InputSelect>
            </MudPaper>
            <div>
                <p>Grouped Data based on Data Factory: @selectedFactory (average of values are taken for each day)
                    <br>Average of CpuMHz values is taken to show the general idea. Data, therefore, is not accurate.
                    <br>Average CpuMHz of Data Factory @selectedFactory: @avgCpuMHz
                    <br>Distinct CpuMHz values: @string.Join(", ", factoryData.DistinctCPUs)
                    <br>Average Utilization Rate: @factoryData.AverageUtilizationRate%
                    <br>Peak Utilization Rate: @factoryData.PeakUtilizationRate%
                </p>
                @if (factoryData.IsUnderutilized)
                {
                    <p style="color: red;">IPCs in Data Factory @selectedFactory are on average underutilized.</p>
                }
                else
                {
                    <p style="color: green;">IPCs in Data Factory @selectedFactory are on average not underutilized.</p>
                }
            </div>
            <MudPaper Class="pa-4 mt-2 mb-2">
                <MudChart 
                    ChartType="MudBlazor.ChartType.Line" 
                    ChartSeries="@factoryData.Series" 
                    @bind-SelectedIndex="Index"  
                    Width="100%" Height="350" 
                    ChartOptions="@Options"/>
            </MudPaper>
        </div>
    }
}

@code 
{
    private bool isLoading = true;
    // variables for line chart
    private List<ChartSeries> Series = new List<ChartSeries>();
    private string[] XAxisLabels = Array.Empty<string>();
    private int Index = -1;
    private ChartOptions Options = new ChartOptions();
    private Dictionary<int, ChartData> chartDataByFactory = new Dictionary<int, ChartData>();

    // variables for data
    private string csvFilePath = "sample-data/testcase_smart_applicator_V8.2_020823.zip.csv";
    private List<IPCData> IPCData = new List<IPCData>();
    private List<IPCData> selectedData = new List<IPCData>();
    private int avgThreshold = 10;
    private int peakThreshold = 20;
    private int avgCpuMHz = 0;

    // variables for input select
    public int selectedFactory { get; set; }
    private List<int> FactoryValues = new List<int>();

    protected override async Task OnInitializedAsync()
    {
        isLoading = true;
        await LoadData();
        isLoading = false;
    }

    private async Task LoadData()
    {
        IPCData = await DataService.LoadDataAsync(csvFilePath);
        // Group data by value of Data Factory, then by date, and take averages of avg and max Values for each day
        var groupedData = IPCData
            .GroupBy(d => new { d.DataFactory, d.CpuMHz })
            .SelectMany(factoryGroup => 
                factoryGroup.GroupBy(g => g.Time.Date)
                    .Select(dateGroup => new IPCData
                    {
                        Time = dateGroup.Key,
                        IPC = string.Join(",", dateGroup.Select(d => d.IPC).Distinct()), 
                        DataFactory = factoryGroup.Key.DataFactory,
                        AvgValue = dateGroup.Average(d => d.AvgValue),
                        MaxValue = dateGroup.Average(d => d.MaxValue),
                        CpuMHz = factoryGroup.Key.CpuMHz 
                    }
                )
            )
            .ToList();

        // get distinct factory values
        FactoryValues = groupedData.Select(d => d.DataFactory).Distinct().ToList();
        // for each factory, load data
        foreach (var factory in FactoryValues)
        {
            LoadFactoryChartData(groupedData, factory);
        }
        // set default selected factory
        selectedFactory = FactoryValues.FirstOrDefault();

        var ipcData = IPCData
            .Where(d => d.IPC.Equals("ITLT4301"))
            .OrderBy(d => d.Time)
            .ToList();

        XAxisLabels = ipcData
            .Select((d, index) => index % 2 == 0 ? d.Time.ToString("dd") : "")
            .ToArray();
    }
    private class ChartData
    {
        public List<ChartSeries> Series { get; set; }
        public string[] XAxisLabels { get; set; }
        public double AverageUtilizationRate { get; set; }
        public double PeakUtilizationRate { get; set; }
        public bool IsUnderutilized { get; set; }
        public List<string> DistinctIPCs { get; set; }
        public List<int> DistinctCPUs { get; set; }
    }
    private void OnFactorySelectionChange(ChangeEventArgs e)
    {
        selectedFactory = int.Parse(e.Value.ToString());
        StateHasChanged();
    }
    private void LoadFactoryChartData(List<IPCData> groupedData, int factory)
    {
        var dataFactory = groupedData.Where(d => d.DataFactory == factory).ToList();
        var maxValues = dataFactory.Select(d => d.MaxValue).ToArray();
        var avgValues = dataFactory.Select(d => d.AvgValue).ToArray();
        var distinctCpu = dataFactory.Select(d => d.CpuMHz).Distinct().ToList();
        avgCpuMHz = (int)dataFactory.Select(d => d.CpuMHz).Average();
        var averageUtilizationRate = Math.Round(avgValues.Average() / avgCpuMHz * 100, 2);
        var peakUtilizationRate = Math.Round(maxValues.Average() / avgCpuMHz * 100, 2);
        var maxUtilizationRate = Math.Round(maxValues.Max() / avgCpuMHz * 100, 2);
        var isUnderutilized = averageUtilizationRate < avgThreshold &&
            peakUtilizationRate < peakThreshold;
        var distinctIPCs = dataFactory.Select(d => d.IPC).Distinct().ToList();

        var ChartSeries = new List<ChartSeries>
        {
            new ChartSeries { Name = "Peak Utilization", Data = maxValues },
            new ChartSeries { Name = "Average Utilization", Data = avgValues }
        };

        chartDataByFactory.Add(factory, new ChartData 
        { 
            Series = ChartSeries, 
            AverageUtilizationRate = averageUtilizationRate,
            PeakUtilizationRate = peakUtilizationRate,
            IsUnderutilized = isUnderutilized,
            DistinctCPUs = distinctCpu,
            DistinctIPCs = distinctIPCs
        });
    }
}